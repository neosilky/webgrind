<?php
// Handle static files with PHP built-in webserver
if (PHP_SAPI == 'cli-server') {
    if (is_file(realpath(__DIR__ . $_SERVER['REQUEST_URI']))) {
        return false;
    }
}

class Webgrind_Config
{

    static $webgrindVersion = '1.5';

    static $hideWebgrindProfiles = true;

    /**
     * Writable dir for information storage.
     * If empty, will use system tmp folder or xdebug tmp
     */
    static $storageDir = '';
    static $profilerDir = 'test';

    /**
     * Suffix for preprocessed files
     */
    static $preprocessedSuffix = '.webgrind';

    /**
     * Image type of graph to output
     * Can be png or svg
     */
    static $graphImageType = 'svg';

    static $defaultTimezone = 'Europe/Copenhagen';
    static $dateFormat = 'Y-m-d H:i:s';
    static $defaultCostformat = 'percent'; // 'percent', 'usec' or 'msec'
    static $defaultFunctionPercentage = 90;
    static $defaultHideInternalFunctions = false;

    /**
     * Path to python executable
     */
    static $pythonExecutable = '/usr/bin/python';

    /**
     * Path to graphviz dot executable
     */
    static $dotExecutable = '/usr/bin/dot';

    /**
     * sprintf compatible format for generating links to source files.
     * %1$s will be replaced by the full path name of the file
     * %2$d will be replaced by the linenumber
     */
    static $fileUrlFormat = 'index.php?op=fileviewer&file=%1$s#line%2$d'; // Built in fileviewer
    //static $fileUrlFormat = 'txmt://open/?url=file://%1$s&line=%2$d'; // Textmate
    //static $fileUrlFormat = 'file://%1$s'; // ?

    /**
     * format of the trace drop down list
     * default is: invokeurl (tracefile_name) [tracefile_size]
     * the following options will be replaced:
     *   %i - invoked url
     *   %f - trace file name
     *   %s - size of trace file
     *   %m - modified time of file name (in dateFormat specified above)
     */
    static $traceFileListFormat = '%i (%f) [%s]';

    /**
     * Proxy functions are stepped over transparently. Functions listed here
     * MUST make exactly one (though not necessarily the same one) function
     * call per execution.
     */
    static $proxyFunctions = array( // resolve dynamic function calls in-place
        'php::call_user_func',
        'php::call_user_func_array',
    );
    //static $proxyFunctions = array(); // do not skip any functions

    /**
     * Specify which fields display, and the order to display them. Uncomment
     * entries to enable, move entries to change order.
     */
    static $tableFields = array(
        'Invocation Count',
        'Total Self Cost',
        //'Average Self Cost',
        'Total Inclusive Cost',
        //'Average Inclusive Cost',
    );

    #########################
    # BELOW NOT FOR EDITING #
    #########################

    /**
     * Regex that matches the trace files generated by xdebug
     */
    static function xdebugOutputFormat()
    {
        $outputName = ini_get('xdebug.profiler_output_name');
        if ($outputName == '') // Ini value not defined
            $outputName = '/^cachegrind\.out\..+$/';
        else
            $outputName = '/^' . preg_replace('/(%[^%])+/', '.+', $outputName) . '$/';
        return $outputName;
    }

    /**
     * Directory to search for trace files
     */
    static function xdebugOutputDir()
    {
        $dir = ini_get('xdebug.profiler_output_dir');
        if ($dir == '') // Ini value not defined
            return realpath(Webgrind_Config::$profilerDir) . '/';
        return realpath($dir) . '/';
    }

    /**
     * Writable dir for information storage
     */
    static function storageDir()
    {
        if (!empty(Webgrind_Config::$storageDir))
            return realpath(Webgrind_Config::$storageDir) . '/';

        if (!function_exists('sys_get_temp_dir') || !is_writable(sys_get_temp_dir())) {
            // use xdebug setting
            return Webgrind_Config::xdebugOutputDir();
        }
        return realpath(sys_get_temp_dir()) . '/';
    }

    /**
     * Binary version of the preprocessor (for faster preprocessing)
     *
     * If the proper tools are installed and the bin dir is writeable for php,
     * automatically compile it (when necessary).
     * Automatic compilation disabled if `bin/make-failed` exists.
     * Run `make` in the webgrind root directory to manually compile.
     */
    static function getBinaryPreprocessor()
    {
        $localBin = __DIR__ . '/bin/';
        $makeFailed = $localBin . 'make-failed';
        $binary = $localBin . 'preprocessor';

        if (!file_exists($binary) && is_writable($localBin) && !file_exists($makeFailed)) {
            $success = static::compileBinaryPreprocessor();
            if (!$success || !file_exists($binary)) {
                touch($makeFailed);
            }
        }

        return $binary;
    }

    static function compileBinaryPreprocessor()
    {
        $make = '/usr/bin/make';
        if (is_executable($make)) {
            $cwd = getcwd();
            chdir(__DIR__);
            exec($make, $output, $retval);
            chdir($cwd);
            return $retval == 0;
        }
        return false;
    }
}

class Webgrind_Reader
{
    const FILE_FORMAT_VERSION = 7;

    const NR_FORMAT = 'V';

    const NR_SIZE = 4;

    const ENTRY_POINT = '{main}';

    const CALLINFORMATION_LENGTH = 4;

    const FUNCTIONINFORMATION_LENGTH = 6;

    private $headersPos;

    private $functionPos;

    private $headers = null;

    private $costFormat;

    function __construct($dataFile, $costFormat)
    {
        $this->fp = @fopen($dataFile, 'rb');
        if (!$this->fp)
            throw new Exception('Error opening file!');

        $this->costFormat = $costFormat;
        $this->init();
    }

    private function init()
    {
        list($version, $this->headersPos, $functionCount) = $this->read(3);
        if ($version != self::FILE_FORMAT_VERSION)
            throw new Exception('Datafile not correct version. Found ' . $version . ' expected ' . self::FILE_FORMAT_VERSION);
        $this->functionPos = $this->read($functionCount);
        if (!is_array($this->functionPos))
            $this->functionPos = [$this->functionPos];
    }

    function getFunctionCount()
    {
        return count($this->functionPos);
    }

    function getFunctionInfo($nr)
    {
        $this->seek($this->functionPos[$nr]);

        list($line, $summedSelfCost, $summedInclusiveCost, $invocationCount, $calledFromCount, $subCallCount) = $this->read(self::FUNCTIONINFORMATION_LENGTH);

        $this->seek(self::NR_SIZE * self::CALLINFORMATION_LENGTH * ($calledFromCount + $subCallCount), SEEK_CUR);
        $file = $this->readLine();
        $function = $this->readLine();

        $result = array(
            'file' => $file,
            'line' => $line,
            'functionName' => $function,
            'summedSelfCost' => $summedSelfCost,
            'summedInclusiveCost' => $summedInclusiveCost,
            'invocationCount' => $invocationCount,
            'calledFromInfoCount' => $calledFromCount,
            'subCallInfoCount' => $subCallCount
        );
        $result['summedSelfCostRaw'] = $result['summedSelfCost'];
        $result['summedSelfCost'] = $this->formatCost($result['summedSelfCost']);
        $result['summedInclusiveCost'] = $this->formatCost($result['summedInclusiveCost']);

        return $result;
    }

    function getCalledFromInfo($functionNr, $calledFromNr)
    {
        $this->seek(
            $this->functionPos[$functionNr]
            + self::NR_SIZE
            * (self::CALLINFORMATION_LENGTH * $calledFromNr + self::FUNCTIONINFORMATION_LENGTH)
        );

        $data = $this->read(self::CALLINFORMATION_LENGTH);

        $result = array(
            'functionNr' => $data[0],
            'line' => $data[1],
            'callCount' => $data[2],
            'summedCallCost' => $data[3]
        );

        $result['summedCallCost'] = $this->formatCost($result['summedCallCost']);

        return $result;
    }

    function getSubCallInfo($functionNr, $subCallNr)
    {
        // Sub call count is the second last number in the FUNCTION_INFORMATION block
        $this->seek($this->functionPos[$functionNr] + self::NR_SIZE * (self::FUNCTIONINFORMATION_LENGTH - 2));
        $calledFromInfoCount = $this->read();
        $this->seek((($calledFromInfoCount + $subCallNr) * self::CALLINFORMATION_LENGTH + 1) * self::NR_SIZE, SEEK_CUR);
        $data = $this->read(self::CALLINFORMATION_LENGTH);

        $result = array(
            'functionNr' => $data[0],
            'line' => $data[1],
            'callCount' => $data[2],
            'summedCallCost' => $data[3]
        );

        $result['summedCallCost'] = $this->formatCost($result['summedCallCost']);

        return $result;
    }

    function getHeader($header)
    {
        if ($this->headers == null) { // Cache headers
            $this->seek($this->headersPos);
            $this->headers = array(
                'runs' => 0,
                'summary' => 0,
                'cmd' => '',
                'creator' => '',
            );
            while ($line = $this->readLine()) {
                $parts = explode(': ', $line);
                if ($parts[0] == 'summary') {
                    // According to https://github.com/xdebug/xdebug/commit/926808a6e0204f5835a617caa3581b45f6d82a6c#diff-1a570e993c4d7f2e341ba24905b8b2cdR355
                    // summary now includes time + memory usage, webgrind only tracks the time from the summary
                    $subParts = explode(' ', $parts[1]);
                    $this->headers['runs']++;
                    $this->headers['summary'] += $subParts[0];
                } else {
                    $this->headers[$parts[0]] = $parts[1];
                }
            }
        }

        return $this->headers[$header];
    }

    function formatCost($cost, $format = null)
    {
        if ($format == null)
            $format = $this->costFormat;

        if ($format == 'percent') {
            $total = $this->getHeader('summary');
            $result = ($total == 0) ? 0 : ($cost * 100) / $total;
            return number_format($result, 2, '.', '');
        }

        if ($format == 'msec') {
            return round($cost / 1000, 0);
        }

        // Default usec
        return $cost;
    }

    private function read($numbers = 1)
    {
        $values = unpack(self::NR_FORMAT . $numbers, fread($this->fp, self::NR_SIZE * $numbers));
        if ($numbers == 1)
            return $values[1];
        else
            return array_values($values); // reindex and return
    }

    private function readLine()
    {
        $result = fgets($this->fp);
        if ($result)
            return trim($result);
        else
            return $result;
    }

    private function seek($offset, $whence = SEEK_SET)
    {
        return fseek($this->fp, $offset, $whence);
    }

    static function parse($inFile, $outFile)
    {
        $preprocessor = Webgrind_Config::getBinaryPreprocessor();
        if (!is_executable($preprocessor)) {
            return false;
        }

        $cmd = escapeshellarg($preprocessor) . ' ' . escapeshellarg($inFile) . ' ' . escapeshellarg($outFile);
        foreach (Webgrind_Config::$proxyFunctions as $function) {
            $cmd .= ' ' . escapeshellarg($function);
        }
        exec($cmd, $output, $ret);
        if ($ret == 0) {
            return;
        }

        $in = @fopen($inFile, 'rb');
        if (!$in)
            throw new Exception('Could not open ' . $inFile . ' for reading.');
        $out = @fopen($outFile, 'w+b');
        if (!$out)
            throw new Exception('Could not open ' . $outFile . ' for writing.');

        $proxyFunctions = array_flip(Webgrind_Config::$proxyFunctions);
        $proxyQueue = [];
        $nextFuncNr = 0;
        $functionNames = [];
        $functions = [];
        $headers = [];

        // Read information into memory
        while (($line = fgets($in))) {
            if (substr($line, 0, 3) === 'fl=') {
                // Found invocation of function. Read function name
                fscanf($in, "fn=%[^\n\r]s", $function);
                $function = self::getCompressedName($function, false);
                // Special case for ENTRY_POINT - it contains summary header
                if (self::ENTRY_POINT == $function) {
                    fgets($in);
                    $headers[] = fgets($in);
                    fgets($in);
                }
                // Cost line
                fscanf($in, "%d %d", $lnr, $cost);

                if (!isset($functionNames[$function])) {
                    $index = $nextFuncNr++;
                    $functionNames[$function] = $index;
                    if (isset($proxyFunctions[$function])) {
                        $proxyQueue[$index] = array();
                    }
                    $functions[$index] = array(
                        'filename' => self::getCompressedName(substr(trim($line), 3), true),
                        'line' => $lnr,
                        'invocationCount' => 1,
                        'summedSelfCost' => $cost,
                        'summedInclusiveCost' => $cost,
                        'calledFromInformation' => array(),
                        'subCallInformation' => array()
                    );
                } else {
                    $index = $functionNames[$function];
                    $functions[$index]['invocationCount']++;
                    $functions[$index]['summedSelfCost'] += $cost;
                    $functions[$index]['summedInclusiveCost'] += $cost;
                }
            } else if (substr($line, 0, 4) === 'cfn=') {
                // Found call to function. ($function/$index should contain function call originates from)
                $calledFunctionName = self::getCompressedName(substr(trim($line), 4), false);
                // Skip call line
                fgets($in);
                // Cost line
                fscanf($in, "%d %d", $lnr, $cost);

                // Current function is a proxy -> skip
                if (isset($proxyQueue[$index])) {
                    $proxyQueue[$index][] = array(
                        'calledIndex' => $functionNames[$calledFunctionName],
                        'lnr' => $lnr,
                        'cost' => $cost,
                    );
                    continue;
                }

                $calledIndex = $functionNames[$calledFunctionName];
                // Called a proxy
                if (isset($proxyQueue[$calledIndex])) {
                    $data = array_shift($proxyQueue[$calledIndex]);
                    $calledIndex = $data['calledIndex'];
                    $lnr = $data['lnr'];
                    $cost = $data['cost'];
                }

                $functions[$index]['summedInclusiveCost'] += $cost;

                $key = $index . $lnr;
                if (!isset($functions[$calledIndex]['calledFromInformation'][$key])) {
                    $functions[$calledIndex]['calledFromInformation'][$key] = array('functionNr' => $index, 'line' => $lnr, 'callCount' => 0, 'summedCallCost' => 0);
                }

                $functions[$calledIndex]['calledFromInformation'][$key]['callCount']++;
                $functions[$calledIndex]['calledFromInformation'][$key]['summedCallCost'] += $cost;

                $calledKey = $calledIndex . $lnr;
                if (!isset($functions[$index]['subCallInformation'][$calledKey])) {
                    $functions[$index]['subCallInformation'][$calledKey] = array('functionNr' => $calledIndex, 'line' => $lnr, 'callCount' => 0, 'summedCallCost' => 0);
                }

                $functions[$index]['subCallInformation'][$calledKey]['callCount']++;
                $functions[$index]['subCallInformation'][$calledKey]['summedCallCost'] += $cost;

            } else if (strpos($line, ': ') !== false) {
                // Found header
                $headers[] = $line;
            }
        }

        $functionNames = array_flip($functionNames);

        // Write output
        $functionCount = sizeof($functions);
        fwrite($out, pack(self::NR_FORMAT . '*', self::FILE_FORMAT_VERSION, 0, $functionCount));
        // Make room for function addresses
        fseek($out, self::NR_SIZE * $functionCount, SEEK_CUR);
        $functionAddresses = array();
        foreach ($functions as $index => $function) {
            $functionAddresses[] = ftell($out);
            $calledFromCount = sizeof($function['calledFromInformation']);
            $subCallCount = sizeof($function['subCallInformation']);
            fwrite($out, pack(self::NR_FORMAT . '*', $function['line'], $function['summedSelfCost'], $function['summedInclusiveCost'], $function['invocationCount'], $calledFromCount, $subCallCount));
            // Write called from information
            foreach ((array)$function['calledFromInformation'] as $call) {
                fwrite($out, pack(self::NR_FORMAT . '*', $call['functionNr'], $call['line'], $call['callCount'], $call['summedCallCost']));
            }
            // Write sub call information
            foreach ((array)$function['subCallInformation'] as $call) {
                fwrite($out, pack(self::NR_FORMAT . '*', $call['functionNr'], $call['line'], $call['callCount'], $call['summedCallCost']));
            }

            fwrite($out, $function['filename'] . "\n" . $functionNames[$index] . "\n");
        }
        $headersPos = ftell($out);
        // Write headers
        foreach ($headers as $header) {
            fwrite($out, $header);
        }

        // Write addresses
        fseek($out, self::NR_SIZE, SEEK_SET);
        fwrite($out, pack(self::NR_FORMAT, $headersPos));
        // Skip function count
        fseek($out, self::NR_SIZE, SEEK_CUR);
        // Write function addresses
        foreach ($functionAddresses as $address) {
            fwrite($out, pack(self::NR_FORMAT, $address));
        }

        fclose($in);
        fclose($out);
    }

    static function getCompressedName($name, $isFile)
    {
        global $compressedNames;
        if (!preg_match("/\((\d+)\)(.+)?/", $name, $matches)) {
            return $name;
        }
        $functionIndex = $matches[1];
        if (isset($matches[2])) {
            $compressedNames[$isFile][$functionIndex] = trim($matches[2]);
        } else if (!isset($compressedNames[$isFile][$functionIndex])) {
            return $name; // should not happen - is file valid?
        }
        return $compressedNames[$isFile][$functionIndex];
    }
}

class Webgrind_FileHandler
{

    private static $singleton = null;

    public static function getInstance()
    {
        if (self::$singleton == null)
            self::$singleton = new self();
        return self::$singleton;
    }

    private function __construct()
    {
        // Get list of files matching the defined format
        $files = $this->getFiles(Webgrind_Config::xdebugOutputFormat(), Webgrind_Config::xdebugOutputDir());

        // Get list of preprocessed files
        $prepFiles = $this->getPrepFiles('/\\' . Webgrind_Config::$preprocessedSuffix . '$/', Webgrind_Config::storageDir());
        // Loop over the preprocessed files.
        foreach ($prepFiles as $fileName => $prepFile) {
            $fileName = str_replace(Webgrind_Config::$preprocessedSuffix, '', $fileName);

            // If it is older than its corrosponding original: delete it.
            // If it's original does not exist: delete it
            if (!isset($files[$fileName]) || $files[$fileName]['mtime'] > $prepFile['mtime'])
                unlink($prepFile['absoluteFilename']);
            else
                $files[$fileName]['preprocessed'] = true;
        }
        // Sort by mtime
        uasort($files, function ($a, $b) {
            if ($a['mtime'] == $b['mtime'])
                return 0;

            return ($a['mtime'] > $b['mtime']) ? -1 : 1;
        });

        $this->files = $files;
    }

    private function getInvokeUrl($file)
    {
        if (preg_match('/\.webgrind$/', $file))
            return 'Webgrind internal';

        // Grab name of invoked file.
        $fp = fopen($file, 'r');
        $invokeUrl = '';
        while ((($line = fgets($fp)) !== FALSE) && !strlen($invokeUrl)) {
            if (preg_match('/^cmd: (.*)$/', $line, $parts)) {
                $invokeUrl = isset($parts[1]) ? $parts[1] : '';
            }
        }
        fclose($fp);
        if (!strlen($invokeUrl))
            $invokeUrl = 'Unknown!';

        return $invokeUrl;
    }

    private function getFiles($format, $dir)
    {
        $list = preg_grep($format, scandir($dir));
        $files = array();

        # Moved this out of loop to run faster
        if (function_exists('xdebug_get_profiler_filename'))
            $selfFile = realpath(xdebug_get_profiler_filename());
        else
            $selfFile = '';

        foreach ($list as $file) {
            $absoluteFilename = $dir . $file;

            // Exclude webgrind preprocessed files
            if (false !== strstr($absoluteFilename, Webgrind_Config::$preprocessedSuffix))
                continue;

            // Make sure that script never parses the profile currently being generated. (infinite loop)
            if ($selfFile == realpath($absoluteFilename))
                continue;

            $invokeUrl = rtrim($this->getInvokeUrl($absoluteFilename));
            if (Webgrind_Config::$hideWebgrindProfiles && $invokeUrl == dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'index.php')
                continue;

            $files[$file] = array('absoluteFilename' => $absoluteFilename,
                'mtime' => filemtime($absoluteFilename),
                'preprocessed' => false,
                'invokeUrl' => $invokeUrl,
                'filesize' => $this->bytestostring(filesize($absoluteFilename))
            );
        }
        return $files;
    }

    private function getPrepFiles($format, $dir)
    {
        $list = preg_grep($format, scandir($dir));
        $files = array();

        foreach ($list as $file) {
            $absoluteFilename = $dir . $file;

            // Make sure that script does not include the profile currently being generated. (infinite loop)
            if (function_exists('xdebug_get_profiler_filename') && realpath(xdebug_get_profiler_filename()) == realpath($absoluteFilename))
                continue;

            $files[$file] = array('absoluteFilename' => $absoluteFilename,
                'mtime' => filemtime($absoluteFilename),
                'preprocessed' => true,
                'filesize' => $this->bytestostring(filesize($absoluteFilename))
            );
        }
        return $files;
    }

    public function getTraceList()
    {
        $result = array();
        foreach ($this->files as $fileName => $file) {
            $result[] = array('filename' => $fileName,
                'invokeUrl' => str_replace($_SERVER['DOCUMENT_ROOT'] . '/', '', $file['invokeUrl']),
                'filesize' => $file['filesize'],
                'mtime' => date(Webgrind_Config::$dateFormat, $file['mtime'])
            );
        }
        return $result;
    }

    public function getTraceReader($file, $costFormat)
    {
        $prepFile = Webgrind_Config::storageDir() . $file . Webgrind_Config::$preprocessedSuffix;
        try {
            $r = new Webgrind_Reader($prepFile, $costFormat);
        } catch (Exception $e) {
            // Preprocessed file does not exist or other error
            Webgrind_Reader::parse(Webgrind_Config::xdebugOutputDir() . $file, $prepFile);
            $r = new Webgrind_Reader($prepFile, $costFormat);
        }
        return $r;
    }

    private function bytestostring($size, $precision = 0)
    {
        $sizes = array('YB', 'ZB', 'EB', 'PB', 'TB', 'GB', 'MB', 'KB', 'B');
        $total = count($sizes);

        while ($total-- && $size > 1024) {
            $size /= 1024;
        }
        return round($size, $precision) . $sizes[$total];
    }
}

set_time_limit(0);

// Make sure we have a timezone for date functions.
if (ini_get('date.timezone') == '')
    date_default_timezone_set(Webgrind_Config::$defaultTimezone);

function get($param, $default = false)
{
    return (isset($_GET[$param]) ? $_GET[$param] : $default);
}

function sendJson($object)
{
    header('Content-type: application/json');
    echo json_encode($object);
    exit;
}

try {
    switch (get('op')) {
        case 'file_list':
            sendJson(Webgrind_FileHandler::getInstance()->getTraceList());
            break;
        case 'function_list':
            $dataFile = get('dataFile');
            if ($dataFile == '0') {
                $files = Webgrind_FileHandler::getInstance()->getTraceList();
                $dataFile = $files[0]['filename'];
            }
            $reader = Webgrind_FileHandler::getInstance()->getTraceReader($dataFile, get('costFormat', Webgrind_Config::$defaultCostformat));
            $functions = [];
            $shownTotal = 0;
            $breakdown = ['internal' => 0, 'procedural' => 0, 'class' => 0, 'include' => 0];

            for ($i = 0; $i < $reader->getFunctionCount(); $i++) {
                $functionInfo = $reader->getFunctionInfo($i);

                if (false !== strpos($functionInfo['functionName'], 'php::')) {
                    $breakdown['internal'] += $functionInfo['summedSelfCostRaw'];
                    $humanKind = 'internal';
                } else if (false !== strpos($functionInfo['functionName'], 'require_once::') ||
                    false !== strpos($functionInfo['functionName'], 'require::') ||
                    false !== strpos($functionInfo['functionName'], 'include_once::') ||
                    false !== strpos($functionInfo['functionName'], 'include::')) {
                    $breakdown['include'] += $functionInfo['summedSelfCostRaw'];
                    $humanKind = 'include';
                } else {
                    if (false !== strpos($functionInfo['functionName'], '->') || false !== strpos($functionInfo['functionName'], '::')) {
                        $breakdown['class'] += $functionInfo['summedSelfCostRaw'];
                        $humanKind = 'class';
                    } else {
                        $breakdown['procedural'] += $functionInfo['summedSelfCostRaw'];
                        $humanKind = 'procedural';
                    }
                }
                if (!(int)get('hideInternals', 0) || strpos($functionInfo['functionName'], 'php::') === false) {
                    $shownTotal += $functionInfo['summedSelfCostRaw'];
                    $functions[$i] = $functionInfo;
                    $functions[$i]['nr'] = $i;
                    $functions[$i]['humanKind'] = $humanKind;
                }
            }

            usort($functions, function ($a, $b) {
                $a = $a['summedSelfCostRaw'];
                $b = $b['summedSelfCostRaw'];

                if ($a == $b) {
                    return 0;
                }
                return ($a > $b) ? -1 : 1;
            });

            $remainingCost = $shownTotal * get('showFraction');

            $result['functions'] = array();
            foreach ($functions as $function) {
                $remainingCost -= $function['summedSelfCostRaw'];
                $function['file'] = urlencode($function['file']);
                $result['functions'][] = $function;
                if ($remainingCost < 0)
                    break;
            }

            $result['summedInvocationCount'] = $reader->getFunctionCount();
            $result['summedRunTime'] = $reader->formatCost($reader->getHeader('summary'), 'msec');
            $result['dataFile'] = $dataFile;
            $result['invokeUrl'] = $reader->getHeader('cmd');
            $result['runs'] = $reader->getHeader('runs');
            $result['breakdown'] = $breakdown;
            $result['mtime'] = date(Webgrind_Config::$dateFormat, filemtime(Webgrind_Config::xdebugOutputDir() . $dataFile));

            $creator = preg_replace('/[^0-9\.]/', '', $reader->getHeader('creator'));
            $result['linkToFunctionLine'] = version_compare($creator, '2.1') > 0;

            sendJson($result);
            break;
        case 'callinfo_list':
            $reader = Webgrind_FileHandler::getInstance()->getTraceReader(get('file'), get('costFormat', Webgrind_Config::$defaultCostformat));
            $functionNr = get('functionNr');
            $function = $reader->getFunctionInfo($functionNr);

            $result = array('calledFrom' => array(), 'subCalls' => array());
            $foundInvocations = 0;

            for ($i = 0; $i < $function['calledFromInfoCount']; $i++) {
                $invo = $reader->getCalledFromInfo($functionNr, $i);
                $foundInvocations += $invo['callCount'];
                $callerInfo = $reader->getFunctionInfo($invo['functionNr']);
                $invo['file'] = urlencode($callerInfo['file']);
                $invo['callerFunctionName'] = $callerInfo['functionName'];
                $result['calledFrom'][] = $invo;
            }
            $result['calledByHost'] = ($foundInvocations < $function['invocationCount']);

            for ($i = 0; $i < $function['subCallInfoCount']; $i++) {
                $invo = $reader->getSubCallInfo($functionNr, $i);
                $callInfo = $reader->getFunctionInfo($invo['functionNr']);
                $invo['file'] = urlencode($function['file']); // Sub call to $callInfo['file'] but from $function['file']
                $invo['callerFunctionName'] = $callInfo['functionName'];
                $result['subCalls'][] = $invo;
            }
            sendJson($result);
            break;
        case 'clear_files':
            $files = Webgrind_FileHandler::getInstance()->getTraceList();
            if (!$files) {
                sendJson(['done' => 'no files found']);
                break;
            }
            $format = array();
            foreach ($files as $file) {
                unlink(Webgrind_Config::xdebugOutputDir() . $file['filename']);
                $format[] = preg_quote($file['filename'], '/');
            }
            $files = preg_grep('/' . implode('|', $format) . '/', scandir(Webgrind_Config::storageDir()));
            foreach ($files as $file) {
                unlink(Webgrind_Config::storageDir() . $file);
            }
            sendJson(['done' => true]);
            break;
        default:
            $welcome = '';
            if (!file_exists(Webgrind_Config::storageDir()) || !is_writable(Webgrind_Config::storageDir())) {
                $welcome .= 'Webgrind $storageDir does not exist or is not writable: <code>' . Webgrind_Config::storageDir() . '</code><br>';
            }
            if (!file_exists(Webgrind_Config::xdebugOutputDir()) || !is_readable(Webgrind_Config::xdebugOutputDir())) {
                $welcome .= 'Webgrind $profilerDir does not exist or is not readable: <code>' . Webgrind_Config::xdebugOutputDir() . '</code><br>';
            }
            if (empty($welcome)) {
                $welcome = 'Select a cachegrind file above<br>(looking in <code>' . Webgrind_Config::xdebugOutputDir() . '</code> for files matching <code>' . Webgrind_Config::xdebugOutputFormat() . '</code>)';
            }
    }
} catch (Exception $e) {
    sendJson(['error' => $e->getMessage() . '<br>' . $e->getFile() . ' @ line ' . $e->getLine()]);
    return;
}
?>
<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>webgrind</title>
    <style>
        body {
            font-family: monospace;
            color: #000000;
            margin: 0;
        }

        a {
            color: #000000;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        img {
            border: 0;
        }

        h2 {
            font-size: 16px;
            margin: 0 0 5px 0;
            font-weight: normal;
        }

        #head {
            padding: 5px 10px 10px 10px;
            border-bottom: 1px solid #404040;
        }

        #logo {
            float: left;
        }

        #logo h1 {
            font-size: 30px;
            padding: 0;
            margin: 0;
        }

        #logo p {
            font-size: 11px;
            margin: 0;
            padding: 0;
        }

        #options {
            float: right;
            padding: 10px 0 0 0;
            margin: 0;
        }

        #main {
            margin: 10px;
        }

        #trace_view {
            display: none;
        }

        #runtime_sum,
        #invocation_sum,
        #shown_sum {
            font-weight: bold;
        }

        div.callinfo_area {
            display: none;
            margin: 5px 5px;
        }

        table.tablesorter {
            border-width: 1px 0 1px 1px;
            border-style: solid;
            border-color: #D9D9D9;
            margin: 10px 0 15px;
            padding: 0;
            font-size: 8pt;
            width: 100%;
            text-align: left;
        }

        table.tablesorter thead tr th, table.tablesorter tfoot tr th {
            background-color: #D7DDE4;
            border-right: 1px solid #CDCDCD;
            border-bottom: 1px solid #CDCDCD;
            font-size: 8pt;
            padding: 4px;
        }

        table.tablesorter thead tr .header {
            background-image: url(img/bg.gif);
            background-repeat: no-repeat;
            background-position: center right;
            cursor: pointer;
        }

        table.tablesorter tbody td {
            color: #000000;
            border-right: 1px solid #D9D9D9;
            padding: 4px;
            vertical-align: top;
        }

        table.tablesorter tbody tr.odd {
            background-color: #EAEEF2;
        }

        table.tablesorter tbody tr.even {
            background-color: #FFFFFF;
        }

        table.tablesorter thead tr .headerSortUp {
            background-image: url(img/asc.gif);
        }

        table.tablesorter thead tr .headerSortDown {
            background-image: url(img/desc.gif);
        }

        table.tablesorter thead tr .headerSortDown, table.tablesorter thead tr .headerSortUp {
            background-color: #9BA8C6;
        }

        td.nr {
            text-align: right;
        }

        th span {
            margin-right: 13px;
        }

        img.list_reload {
            margin: 0 5px;
        }
    </style>
    <link rel="shortcut icon" type="image/ico"
          href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEREREREREAEREREREREQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwAA//8AAAAAAAAAAAAA//8AAAAPAAAADwAA//8AAAADAAAAAwAA//8AAAADAAAAAwAA//8AAAH/AAAB/wAA">
</head>
<body>
<div id="head">
    <div id="logo">
        <h1>webgrind<sup style="font-size:10px">v<?php echo Webgrind_Config::$webgrindVersion ?></sup></h1>
        <p>profiling in the browser</p>
    </div>
    <form id="options" method="get" onsubmit="window.location.hash='';update();return false;">
        <div style="float:right;margin-left:10px">
            <label for="showFraction" style="margin:0 5px">Show</label>
            <select id="showFraction" name="showFraction">
                <?php foreach (array(100, 99.7, 98, 95, 90, 82, 68, 50, 26) as $i): ?>
                    <option value="<?php echo $i / 100 ?>" <?php if ($i == Webgrind_Config::$defaultFunctionPercentage): ?>selected="selected"<?php endif; ?>><?php echo $i ?>%</option>
                <?php endforeach; ?>
            </select>
            <label for="dataFile" style="margin:0 5px">of</label>
            <select id="dataFile" name="dataFile" style="width:200px">
                <option value="0">Auto (newest)</option>
                <?php foreach (Webgrind_FileHandler::getInstance()->getTraceList() as $trace): ?>
                    <option value="<?php echo $trace['filename'] ?>"><?php echo str_replace(array('%i', '%f', '%s', '%m'), array($trace['invokeUrl'], $trace['filename'], $trace['filesize'], $trace['mtime']), Webgrind_Config::$traceFileListFormat); ?></option>
                <?php endforeach; ?>
            </select>
            <img alt="Reload the file list" class="list_reload" src="img/reload.png" onclick="reloadFilelist()">
            <label for="costFormat" style="margin:0 5px">in</label>
            <select id="costFormat" name="costFormat">
                <option value="percent" <?php echo (Webgrind_Config::$defaultCostformat == 'percent') ? 'selected' : '' ?>>percent</option>
                <option value="msec" <?php echo (Webgrind_Config::$defaultCostformat == 'msec') ? 'selected' : '' ?>>milliseconds</option>
                <option value="usec" <?php echo (Webgrind_Config::$defaultCostformat == 'usec') ? 'selected' : '' ?>>microseconds</option>
            </select>
            <input type="submit" value="Update">
            <input type="button" value="&#10006;" onclick="clearFiles()">
        </div>
    </form>
    <div style="clear:both;"></div>
</div>
<div id="main">
    <div id="trace_view">
        <div style="float:left;">
            <h2 id="invoke_url"></h2>
            <span id="data_file"></span> @ <span id="mtime"></span>
            <p>
                <label for="callfilter">Filter:</label>
                <input type="text" style="width:150px" id="callfilter"> (regex too)
                <input type="checkbox" name="negateFilter" value="0" id="negateFilter">
                <label for="negateFilter">Invert filter</label>
                <input type="checkbox" name="hideInternals"
                       value="1" <?php echo (Webgrind_Config::$defaultHideInternalFunctions == 1) ? 'checked' : '' ?>
                       id="hideInternals">
                <label for="hideInternals">Hide PHP functions</label>
            </p>
        </div>
        <div style="float:right;">
            <div id="breakdown" style="margin-bottom:5px;width:320px;height:20px"></div>
            <span id="invocation_sum"></span> different functions called in <span id="runtime_sum"></span> milliseconds
            (<span id="runs"></span> runs, <span id="shown_sum"></span> shown)
        </div>
        <table class="tablesorter" id="function_table" cellspacing="0">
            <thead>
            <tr>
                <th></th>
                <th><span>Function</span></th>
                <th></th>
                <?php foreach (Webgrind_Config::$tableFields as $field): ?>
                    <th><span><?php echo $field ?></span></th>
                <?php endforeach; ?>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.31.1/js/jquery.tablesorter.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.1.2/sprintf.min.js" type="text/javascript"></script>
<script>
    let fileUrlFormat = '<?php echo Webgrind_Config::$fileUrlFormat?>';
    let currentDataFile = null;
    let callInfoLoaded = [];

    function update(specificFile) {
        $.getJSON("index.php",
            {
                dataFile: specificFile || $("#dataFile").val(),
                costFormat: $('#costFormat').val(),
                showFraction: $("#showFraction").val(),
                hideInternals: $('#hideInternals').attr('checked') ? 1 : 0,
                op: 'function_list'
            },
            function (data) {
                if (data.error) {
                    alert(data.error);
                    return;
                }
                callInfoLoaded = [];
                $("#function_table tbody").empty();

                data.functions.forEach(function (rowData) {
                    callInfoLoaded[rowData.nr] = false;
                    let openLink;

                    if (rowData.file === 'php%3Ainternal') {
                        openLink = '<a title="Lookup function" href="https://secure.php.net/' + rowData.functionName.substr(5).replace("->", ".") + '" target="_blank"><img src="img/file.png" alt="O"></a>';
                    } else {
                        if (data.linkToFunctionLine) {
                            openLink = '<a title="Open file and show line" href="' + sprintf(fileUrlFormat, rowData.file, rowData.line) + '" target="_blank"><img src="img/file_line.png" alt="O"></a>';
                        } else {
                            openLink = '<a title="Open file" href="' + sprintf(fileUrlFormat, rowData.file, -1) + '" target="_blank"><img src="img/file.png" alt="O"></a>';
                        }
                    }
                    let functionTableRow = '<tr> \
						<td><img src="img/call_' + rowData.humanKind + '.png" title="' + rowData.humanKind + '"></td> \
						<td> \
							<a id="callinfo_a_' + rowData.nr + '" href="javascript:toggleCallInfo(' + rowData.nr + ')"> \
								<img id="fold_marker_' + rowData.nr + '" src="img/right.gif">&nbsp;&nbsp;' + rowData.functionName + ' \
							</a> \
							<div class="callinfo_area" id="callinfo_area_' + rowData.nr + '"></div> \
						</td> \
						<td>' + openLink + '</td> \
						<?php
                        $dataCodes = array(
                            'Invocation Count' => 'rowData.invocationCount',
                            'Total Self Cost' => 'rowData.summedSelfCost',
                            'Average Self Cost' => 'sprintf("%.2f", rowData.summedSelfCost/rowData.invocationCount)',
                            'Total Inclusive Cost' => 'rowData.summedInclusiveCost',
                            'Average Inclusive Cost' => 'sprintf("%.2f", rowData.summedInclusiveCost/data.invocationCount)',
                        );
                        foreach (Webgrind_Config::$tableFields as $field) {
                            echo "<td class=\"nr\">'.$dataCodes[$field].'</td>";
                        }
                        ?>
                        < /tr>';
                    $("#function_table tbody").append(functionTableRow);
                });

                currentDataFile = data.dataFile;
                $("#data_file").html(data.dataFile);
                $("#invoke_url").html(data.invokeUrl);
                $(document).attr('title', 'webgrind of ' + data.invokeUrl);
                $("#mtime").html(data.mtime);
                $("#shown_sum").html(data.functions.length);
                $("#invocation_sum").html(data.summedInvocationCount);
                $("#runtime_sum").html(data.summedRunTime);
                $("#runs").html(data.runs);

                let breakdown_sum = data.breakdown['internal'] + data.breakdown['procedural'] + data.breakdown['class'] + data.breakdown['include'];
                $("#breakdown").html(
                    '<img src="img/gradient_left.png" height="20" width="10">' +
                    '<img src="img/gradient_internal.png" title="internal functions" height="20" width="' + Math.floor(data.breakdown['internal'] / breakdown_sum * 300) + '">' +
                    '<img src="img/gradient_include.png" title="include/require" height="20" width="' + Math.floor(data.breakdown['include'] / breakdown_sum * 300) + '">' +
                    '<img src="img/gradient_class.png" title="class methods" height="20" width="' + Math.floor(data.breakdown['class'] / breakdown_sum * 300) + '">' +
                    '<img src="img/gradient_procedural.png" title="procedural functions" height="20" width="' + Math.floor(data.breakdown['procedural'] / breakdown_sum * 300) + '">' +
                    '<img src="img/gradient_right.png" height="20" width="10">'
                );

                $("#trace_view").show();

                let functionTable = $("#function_table");
                functionTable.trigger('update');
                <?php
                $sortCol = 0;
                foreach (Webgrind_Config::$tableFields as $idx => $field) {
                    if (strpos($field, 'Cost') !== FALSE) {
                        $sortCol = 3 + $idx;
                        break;
                    }
                }
                $maxCol = 3 + count(Webgrind_Config::$tableFields);
                ?>
                functionTable.trigger("sorton", [[[<?php echo $sortCol?>, 1]]]);

                $('#callfilter').trigger('keyup');
                if (window.location.hash.length > 2)
                    openCallInfo(window.location.hash.replace(/[^0-9]/g, ''));
            }
        );
    }

    function insertCallInfo(functionNr, idPrefix, title, data) {
        if (data.length === 0)
            return;

        let callTable = '<table class="tablesorter" id="' + idPrefix + functionNr + '" cellspacing="0"><thead><tr><th><span>' + title + '</span></th><th><span>Count</span></th><th><span>Total Call Cost</span></th><th></th></tr></thead><tbody></tbody></table>';
        $("#callinfo_area_" + functionNr).append(callTable);

        data.forEach(function (data) {
            let callTableRow = '<tr><td>'
                + ($("#callinfo_area_" + data.functionNr).length ? '<img src="img/right.gif">&nbsp;&nbsp;<a href="javascript:openCallInfo(' + data.functionNr + ')">' + data.callerFunctionName + '</a>' : '<img src="img/blank.gif">&nbsp;&nbsp;' + data.callerFunctionName)
                + ' @ ' + data.line + '</td> \
						<td class="nr">' + data.callCount + '</td> \
						<td class="nr">' + data.summedCallCost + '</td> \
						<td><a title="Open file and show line" href="' + sprintf(fileUrlFormat, data.file, data.line) + '" target="_blank"><img src="img/file_line.png" alt="O"></a></td> \
					</tr>';
            $("#" + idPrefix + functionNr + " tbody").append(callTableRow);
        });

        let functionDiv = $("#" + idPrefix + functionNr);

        functionDiv.tablesorter({
            widgets: ['zebra'],
            headers: {
                3: {
                    sorter: false
                }
            }
        });
        functionDiv.trigger("sorton", [[[2, 1]]]);
    }

    function toggleCallInfo(functionNr) {
        let $ciar = $("#callinfo_area_" + functionNr);
        let fmimg = $("#fold_marker_" + functionNr).get(0);
        if ($ciar.is(":visible")) {
            $ciar.hide();
            fmimg.src = 'img/right.gif';
        } else {
            if (!callInfoLoaded[functionNr]) {
                $.getJSON("index.php",
                    {
                        'op': 'callinfo_list',
                        'file': currentDataFile,
                        'functionNr': functionNr,
                        'costFormat': $("#costFormat").val()
                    },
                    function (data) {
                        if (data.error) {
                            alert(data.error);
                            return;
                        }

                        if (data.calledByHost)
                            $("#callinfo_area_" + functionNr).append('<b>Called from script host</b>');

                        insertCallInfo(functionNr, 'sub_calls_table_', 'Calls', data.subCalls);
                        insertCallInfo(functionNr, 'called_from_table_', 'Called From', data.calledFrom);

                        callInfoLoaded[functionNr] = true;
                        window.location.hash = "#callinfo_a_" + functionNr;
                    }
                );
            } else {
                window.location.hash = "#callinfo_a_" + functionNr;
            }
            $ciar.show();
            fmimg.src = 'img/down.gif';
        }
    }

    function openCallInfo(functionNr) {
        let areaEl = $("#callinfo_area_" + functionNr);
        if (areaEl.length) {
            if (areaEl.is(":hidden")) {
                toggleCallInfo(functionNr);
            } else {
                window.location.hash = "#callinfo_a_" + functionNr;
            }
            window.scrollTo(0, areaEl.parent().offset().top);
            setTimeout(function () {
                areaEl.parent().parent().css({'background-color': '#DFECE0'})
            }, 50);
            setTimeout(function () {
                areaEl.parent().parent().css({'background-color': ''})
            }, 600);
        }
    }

    function reloadFilelist() {
        $.getJSON("index.php",
            {'op': 'file_list'},
            function (data) {
                let datafile = $("#dataFile");
                datafile.find('option').remove();
                datafile.append('<option value="0">Auto (newest)</option>');
                data.forEach(function (d) {
                    datafile.append('<option value="' + d['filename'] + '">' + d['invokeUrl'] + ' (' + d['filename'] + ') [' + d['filesize'] + ']' + '</option>');
                });
            }
        );
    }

    function clearFiles() {
        if (!window.confirm('Are you sure you want to clear all files?'))
            return;

        $.getJSON("index.php",
            {'op': 'clear_files'},
            function (data) {
                if (data.error) {
                    alert(data.error);
                    return;
                }
                reloadFilelist();
            }
        );
    }

    $(document).ready(function () {
        $("#function_table").tablesorter({
            widgets: ['zebra'],
            sortInitialOrder: 'desc',
            headers: {
                1: {
                    sorter: false
                },
                2: {
                    sorter: false
                }
            }
        });

        if (document.location.hash) {
            update();
        }

        $("#hideInternals").change(function () {
            update();
        });

        $("#negateFilter").change(function () {
            $('#callfilter').trigger('keyup');
        });

        $("#callfilter").keyup(function () {
            let reg = new RegExp($(this).val(), 'i');
            let negate = $("#negateFilter").is(':checked');
            let row;
            $('#function_table').children('tbody').children('tr').each(function () {
                row = $(this);
                if (!row.find('td:eq(1) a').text().match(reg) === negate)
                    row.css('display', 'table-row');
                else
                    row.css('display', 'none');
            });
        });

        window.addEventListener("hashchange", function () {
            if (window.location.hash.length > 2)
                openCallInfo(window.location.hash.replace(/[^0-9]/g, ''));
        });
    });
</script>
</body>
</html>
