<?php
/**
 * @author Jacob Oettinger
 * @author Joakim NygÃ¥rd
 */

// Handle static files with PHP built-in webserver
if (PHP_SAPI == 'cli-server') {
    if (is_file(realpath(__DIR__ . $_SERVER['REQUEST_URI']))) {
        return false;
    }
}

class Webgrind_Config {

    static $webgrindVersion = '1.5';

    /**
     * Automatically check if a newer version of webgrind is available for download
     */
    static $checkVersion = true;
    static $hideWebgrindProfiles = true;

    /**
     * Writable dir for information storage.
     * If empty, will use system tmp folder or xdebug tmp
     */
    static $storageDir = '';
    static $profilerDir = '/tmp';

    /**
     * Suffix for preprocessed files
     */
    static $preprocessedSuffix = '.webgrind';

    /**
     * Image type of graph to output
     * Can be png or svg
     */
    static $graphImageType = 'svg';

    static $defaultTimezone = 'Europe/Copenhagen';
    static $dateFormat = 'Y-m-d H:i:s';
    static $defaultCostformat = 'percent'; // 'percent', 'usec' or 'msec'
    static $defaultFunctionPercentage = 90;
    static $defaultHideInternalFunctions = false;

    static $promptConfirmationBeforeDeleteFiles = true;

    /**
     * Path to python executable
     */
    static $pythonExecutable = '/usr/bin/python';

    /**
     * Path to graphviz dot executable
     */
    static $dotExecutable = '/usr/bin/dot';

    /**
     * sprintf compatible format for generating links to source files.
     * %1$s will be replaced by the full path name of the file
     * %2$d will be replaced by the linenumber
     */
    static $fileUrlFormat = 'index.php?op=fileviewer&file=%1$s#line%2$d'; // Built in fileviewer
    //static $fileUrlFormat = 'txmt://open/?url=file://%1$s&line=%2$d'; // Textmate
    //static $fileUrlFormat = 'file://%1$s'; // ?

    /**
     * format of the trace drop down list
     * default is: invokeurl (tracefile_name) [tracefile_size]
     * the following options will be replaced:
     *   %i - invoked url
     *   %f - trace file name
     *   %s - size of trace file
     *   %m - modified time of file name (in dateFormat specified above)
     */
    static $traceFileListFormat = '%i (%f) [%s]';

    /**
     * Proxy functions are stepped over transparently. Functions listed here
     * MUST make exactly one (though not necessarily the same one) function
     * call per execution.
     */
    static $proxyFunctions = array( // resolve dynamic function calls in-place
        'php::call_user_func',
        'php::call_user_func_array',
    );
    //static $proxyFunctions = array(); // do not skip any functions

    /**
     * Specify which fields display, and the order to display them. Uncomment
     * entries to enable, move entries to change order.
     */
    static $tableFields = array(
        'Invocation Count',
        'Total Self Cost',
        //'Average Self Cost',
        'Total Inclusive Cost',
        //'Average Inclusive Cost',
    );

    #########################
    # BELOW NOT FOR EDITING #
    #########################

    /**
     * Regex that matches the trace files generated by xdebug
     */
    static function xdebugOutputFormat() {
        $outputName = ini_get('xdebug.profiler_output_name');
        if ($outputName=='') // Ini value not defined
            $outputName = '/^cachegrind\.out\..+$/';
        else
            $outputName = '/^'.preg_replace('/(%[^%])+/', '.+', $outputName).'$/';
        return $outputName;
    }

    /**
     * Directory to search for trace files
     */
    static function xdebugOutputDir() {
        $dir = ini_get('xdebug.profiler_output_dir');
        if ($dir=='') // Ini value not defined
            return realpath(Webgrind_Config::$profilerDir).'/';
        return realpath($dir).'/';
    }

    /**
     * Writable dir for information storage
     */
    static function storageDir() {
        if (!empty(Webgrind_Config::$storageDir))
            return realpath(Webgrind_Config::$storageDir).'/';

        if (!function_exists('sys_get_temp_dir') || !is_writable(sys_get_temp_dir())) {
            // use xdebug setting
            return Webgrind_Config::xdebugOutputDir();
        }
        return realpath(sys_get_temp_dir()).'/';
    }

    /**
     * Binary version of the preprocessor (for faster preprocessing)
     *
     * If the proper tools are installed and the bin dir is writeable for php,
     * automatically compile it (when necessary).
     * Automatic compilation disabled if `bin/make-failed` exists.
     * Run `make` in the webgrind root directory to manually compile.
     */
    static function getBinaryPreprocessor() {
        $localBin = __DIR__.'/bin/';
        $makeFailed = $localBin.'make-failed';
        if (PHP_OS == 'WINNT') {
            $binary = $localBin.'preprocessor.exe';
        } else {
            $binary = $localBin.'preprocessor';
        }

        if (!file_exists($binary) && is_writable($localBin) && !file_exists($makeFailed)) {
            if (PHP_OS == 'WINNT') {
                $success = static::compileBinaryPreprocessorWindows();
            } else {
                $success = static::compileBinaryPreprocessor();
            }
            if (!$success || !file_exists($binary)) {
                touch($makeFailed);
            }
        }

        return $binary;
    }

    static function compileBinaryPreprocessor() {
        $make = '/usr/bin/make';
        if (is_executable($make)) {
            $cwd = getcwd();
            chdir(__DIR__);
            exec($make, $output, $retval);
            chdir($cwd);
            return $retval == 0;
        }
        return false;
    }

    static function compileBinaryPreprocessorWindows() {
        if (getenv('VSAPPIDDIR')) {
            $cwd = getcwd();
            chdir(__DIR__);
            exec('call "%VSAPPIDDIR%\..\Tools\vsdevcmd\ext\vcvars.bat" && nmake -f nmakefile', $output, $retval);
            chdir($cwd);
            return $retval == 0;
        } elseif (getenv('VS140COMNTOOLS')) {
            $cwd = getcwd();
            chdir(__DIR__);
            exec('call "%VS140COMNTOOLS%\vsvars32.bat" && nmake -f nmakefile', $output, $retval);
            chdir($cwd);
            return $retval == 0;
        }
        return false;
    }
}

require './library/FileHandler.php';

// TODO: Errorhandling:
//         No files, outputdir not writable

set_time_limit(0);

// Make sure we have a timezone for date functions.
if (ini_get('date.timezone') == '')
    date_default_timezone_set( Webgrind_Config::$defaultTimezone );

try {
    switch (get('op')) {
        case 'file_list':
            sendJson(Webgrind_FileHandler::getInstance()->getTraceList());
            break;

        case 'function_list':
            $dataFile = get('dataFile');
            if ($dataFile=='0') {
                $files = Webgrind_FileHandler::getInstance()->getTraceList();
                $dataFile = $files[0]['filename'];
            }
            $reader = Webgrind_FileHandler::getInstance()->getTraceReader($dataFile, get('costFormat', Webgrind_Config::$defaultCostformat));
            $functions = array();
            $shownTotal = 0;
            $breakdown = array('internal' => 0, 'procedural' => 0, 'class' => 0, 'include' => 0);

            for ($i=0; $i<$reader->getFunctionCount(); $i++) {
                $functionInfo = $reader->getFunctionInfo($i);

                if (false !== strpos($functionInfo['functionName'], 'php::')) {
                    $breakdown['internal'] += $functionInfo['summedSelfCostRaw'];
                    $humanKind = 'internal';
                } else if (false !== strpos($functionInfo['functionName'], 'require_once::') ||
                          false !== strpos($functionInfo['functionName'], 'require::') ||
                          false !== strpos($functionInfo['functionName'], 'include_once::') ||
                          false !== strpos($functionInfo['functionName'], 'include::')) {
                    $breakdown['include'] += $functionInfo['summedSelfCostRaw'];
                    $humanKind = 'include';
                } else {
                    if (false !== strpos($functionInfo['functionName'], '->') || false !== strpos($functionInfo['functionName'], '::')) {
                        $breakdown['class'] += $functionInfo['summedSelfCostRaw'];
                        $humanKind = 'class';
                    } else {
                        $breakdown['procedural'] += $functionInfo['summedSelfCostRaw'];
                        $humanKind = 'procedural';
                    }
                }
                if (!(int)get('hideInternals', 0) || strpos($functionInfo['functionName'], 'php::') === false) {
                    $shownTotal += $functionInfo['summedSelfCostRaw'];
                    $functions[$i] = $functionInfo;
                    $functions[$i]['nr'] = $i;
                    $functions[$i]['humanKind'] = $humanKind;
                }
            }
            usort($functions,'costCmp');

            $remainingCost = $shownTotal*get('showFraction');

            $result['functions'] = array();
            foreach ($functions as $function) {
                $remainingCost -= $function['summedSelfCostRaw'];
                $function['file'] = urlencode($function['file']);
                $result['functions'][] = $function;
                if ($remainingCost<0)
                    break;
            }
            $result['summedInvocationCount'] = $reader->getFunctionCount();
            $result['summedRunTime'] = $reader->formatCost($reader->getHeader('summary'), 'msec');
            $result['dataFile'] = $dataFile;
            $result['invokeUrl'] = $reader->getHeader('cmd');
            $result['runs'] = $reader->getHeader('runs');
            $result['breakdown'] = $breakdown;
            $result['mtime'] = date(Webgrind_Config::$dateFormat,filemtime(Webgrind_Config::xdebugOutputDir().$dataFile));

            $creator = preg_replace('/[^0-9\.]/', '', $reader->getHeader('creator'));
            $result['linkToFunctionLine'] = version_compare($creator, '2.1') > 0;

            sendJson($result);
        break;

        case 'callinfo_list':
            $reader = Webgrind_FileHandler::getInstance()->getTraceReader(get('file'), get('costFormat', Webgrind_Config::$defaultCostformat));
            $functionNr = get('functionNr');
            $function = $reader->getFunctionInfo($functionNr);

            $result = array('calledFrom'=>array(), 'subCalls'=>array());
            $foundInvocations = 0;
            for ($i=0; $i<$function['calledFromInfoCount']; $i++) {
                $invo = $reader->getCalledFromInfo($functionNr, $i);
                $foundInvocations += $invo['callCount'];
                $callerInfo = $reader->getFunctionInfo($invo['functionNr']);
                $invo['file'] = urlencode($callerInfo['file']);
                $invo['callerFunctionName'] = $callerInfo['functionName'];
                $result['calledFrom'][] = $invo;
            }
            $result['calledByHost'] = ($foundInvocations<$function['invocationCount']);

            for ($i=0; $i<$function['subCallInfoCount']; $i++) {
                $invo = $reader->getSubCallInfo($functionNr, $i);
                $callInfo = $reader->getFunctionInfo($invo['functionNr']);
                $invo['file'] = urlencode($function['file']); // Sub call to $callInfo['file'] but from $function['file']
                $invo['callerFunctionName'] = $callInfo['functionName'];
                $result['subCalls'][] = $invo;
            }
            sendJson($result);
        break;

        case 'fileviewer':
            $file = get('file');

            if ($file && $file!='') {
                $message = '';
                if (!file_exists($file)) {
                    $message = $file.' does not exist.';
                } else if (!is_readable($file)) {
                    $message = $file.' is not readable.';
                } else if (is_dir($file)) {
                    $message = $file.' is a directory.';
                }
            } else {
                $message = 'No file to view';
            }
            require 'templates/fileviewer.phtml';
        break;

        case 'function_graph':
            $dataFile = get('dataFile');
            $showFraction = 100 - intval(get('showFraction') * 100);
            if ($dataFile == '0') {
                $files = Webgrind_FileHandler::getInstance()->getTraceList();
                $dataFile = $files[0]['filename'];
            }

            $filename = Webgrind_Config::storageDir().$dataFile.'-'.$showFraction.Webgrind_Config::$preprocessedSuffix.'.'.Webgrind_Config::$graphImageType;
            if (!file_exists($filename)) {
                // Add enclosing quotes if needed
                foreach (array('pythonExecutable', 'dotExecutable') as $exe) {
                    $item =& Webgrind_Config::$$exe;
                    if (strpos($item, ' ') !== false && !preg_match('/^".+"$/', $item)) {
                        $item = '"'.$item.'"';
                    }
                }
                shell_exec(Webgrind_Config::$pythonExecutable.' library/gprof2dot.py -n '.$showFraction
                           .' -f callgrind '.escapeshellarg(Webgrind_Config::xdebugOutputDir().$dataFile).' | '
                           .Webgrind_Config::$dotExecutable.' -T'.Webgrind_Config::$graphImageType.' -o '.escapeshellarg($filename));
            }

            if (!file_exists($filename)) {
                $file = $filename;
                $message = 'Unable to generate <u>'.$file.'</u> via python: <u>'.Webgrind_Config::$pythonExecutable
                          .'</u> and dot: <u>'.Webgrind_Config::$dotExecutable.'</u>. Please update config.php.';
                require 'templates/fileviewer.phtml';
                break;
            }

            if (Webgrind_Config::$graphImageType == 'svg') {
                header('Content-Type: image/svg+xml');
            } else {
                header('Content-Type: image/'.Webgrind_Config::$graphImageType);
            }
            readfile($filename);
        break;

        case 'version_info':
            $response = @file_get_contents('http://jokkedk.github.io/webgrind/webgrindupdate.json?version='.Webgrind_Config::$webgrindVersion);
            if ($response) {
                header('Content-type: application/json');
                echo $response;
            }
        break;

        case 'clear_files':
            $files = Webgrind_FileHandler::getInstance()->getTraceList();
            if (!$files) {
                sendJson(array('done' => 'no files found'));
                break;
            }
            $format = array();
            foreach ($files as $file) {
                unlink(Webgrind_Config::xdebugOutputDir().$file['filename']);
                $format[] = preg_quote($file['filename'], '/');
            }
            $files = preg_grep('/'.implode('|', $format).'/', scandir(Webgrind_Config::storageDir()));
            foreach ($files as $file) {
                unlink(Webgrind_Config::storageDir().$file);
            }
            sendJson(array('done' => true));
        break;

        default:
            $welcome = '';
            if (!file_exists(Webgrind_Config::storageDir()) || !is_writable(Webgrind_Config::storageDir())) {
                $welcome .= 'Webgrind $storageDir does not exist or is not writeable: <code>'.Webgrind_Config::storageDir().'</code><br>';
            }
            if (!file_exists(Webgrind_Config::xdebugOutputDir()) || !is_readable(Webgrind_Config::xdebugOutputDir())) {
                $welcome .= 'Webgrind $profilerDir does not exist or is not readable: <code>'.Webgrind_Config::xdebugOutputDir().'</code><br>';
            }

            if ($welcome == '') {
                $welcome = 'Select a cachegrind file above<br>(looking in <code>'.Webgrind_Config::xdebugOutputDir().'</code> for files matching <code>'.Webgrind_Config::xdebugOutputFormat().'</code>)';
            }
            require 'templates/index.phtml';
    }
} catch (Exception $e) {
    sendJson(array('error' => $e->getMessage().'<br>'.$e->getFile().', line '.$e->getLine()));
    return;
}

function get($param, $default=false) {
    return (isset($_GET[$param])? $_GET[$param] : $default);
}

function costCmp($a, $b) {
    $a = $a['summedSelfCostRaw'];
    $b = $b['summedSelfCostRaw'];

    if ($a == $b) {
        return 0;
    }
    return ($a > $b) ? -1 : 1;
}

function sendJson($object) {
    header('Content-type: application/json');
    echo json_encode($object);
}
