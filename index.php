<?php
// Handle static files with PHP built-in webserver
if (PHP_SAPI == 'cli-server') {
    if (is_file(realpath(__DIR__ . $_SERVER['REQUEST_URI']))) {
        return false;
    }
}

class Webgrind_Config
{

    static $webgrindVersion = '1.5';

    /**
     * Automatically check if a newer version of webgrind is available for download
     */
    static $checkVersion = true;
    static $hideWebgrindProfiles = true;

    /**
     * Writable dir for information storage.
     * If empty, will use system tmp folder or xdebug tmp
     */
    static $storageDir = '';
    static $profilerDir = 'test';

    /**
     * Suffix for preprocessed files
     */
    static $preprocessedSuffix = '.webgrind';

    /**
     * Image type of graph to output
     * Can be png or svg
     */
    static $graphImageType = 'svg';

    static $defaultTimezone = 'Europe/Copenhagen';
    static $dateFormat = 'Y-m-d H:i:s';
    static $defaultCostformat = 'percent'; // 'percent', 'usec' or 'msec'
    static $defaultFunctionPercentage = 90;
    static $defaultHideInternalFunctions = false;

    /**
     * Path to python executable
     */
    static $pythonExecutable = '/usr/bin/python';

    /**
     * Path to graphviz dot executable
     */
    static $dotExecutable = '/usr/bin/dot';

    /**
     * sprintf compatible format for generating links to source files.
     * %1$s will be replaced by the full path name of the file
     * %2$d will be replaced by the linenumber
     */
    static $fileUrlFormat = 'index.php?op=fileviewer&file=%1$s#line%2$d'; // Built in fileviewer
    //static $fileUrlFormat = 'txmt://open/?url=file://%1$s&line=%2$d'; // Textmate
    //static $fileUrlFormat = 'file://%1$s'; // ?

    /**
     * format of the trace drop down list
     * default is: invokeurl (tracefile_name) [tracefile_size]
     * the following options will be replaced:
     *   %i - invoked url
     *   %f - trace file name
     *   %s - size of trace file
     *   %m - modified time of file name (in dateFormat specified above)
     */
    static $traceFileListFormat = '%i (%f) [%s]';

    /**
     * Proxy functions are stepped over transparently. Functions listed here
     * MUST make exactly one (though not necessarily the same one) function
     * call per execution.
     */
    static $proxyFunctions = array( // resolve dynamic function calls in-place
        'php::call_user_func',
        'php::call_user_func_array',
    );
    //static $proxyFunctions = array(); // do not skip any functions

    /**
     * Specify which fields display, and the order to display them. Uncomment
     * entries to enable, move entries to change order.
     */
    static $tableFields = array(
        'Invocation Count',
        'Total Self Cost',
        //'Average Self Cost',
        'Total Inclusive Cost',
        //'Average Inclusive Cost',
    );

    #########################
    # BELOW NOT FOR EDITING #
    #########################

    /**
     * Regex that matches the trace files generated by xdebug
     */
    static function xdebugOutputFormat()
    {
        $outputName = ini_get('xdebug.profiler_output_name');
        if ($outputName == '') // Ini value not defined
            $outputName = '/^cachegrind\.out\..+$/';
        else
            $outputName = '/^' . preg_replace('/(%[^%])+/', '.+', $outputName) . '$/';
        return $outputName;
    }

    /**
     * Directory to search for trace files
     */
    static function xdebugOutputDir()
    {
        $dir = ini_get('xdebug.profiler_output_dir');
        if ($dir == '') // Ini value not defined
            return realpath(Webgrind_Config::$profilerDir) . '/';
        return realpath($dir) . '/';
    }

    /**
     * Writable dir for information storage
     */
    static function storageDir()
    {
        if (!empty(Webgrind_Config::$storageDir))
            return realpath(Webgrind_Config::$storageDir) . '/';

        if (!function_exists('sys_get_temp_dir') || !is_writable(sys_get_temp_dir())) {
            // use xdebug setting
            return Webgrind_Config::xdebugOutputDir();
        }
        return realpath(sys_get_temp_dir()) . '/';
    }

    /**
     * Binary version of the preprocessor (for faster preprocessing)
     *
     * If the proper tools are installed and the bin dir is writeable for php,
     * automatically compile it (when necessary).
     * Automatic compilation disabled if `bin/make-failed` exists.
     * Run `make` in the webgrind root directory to manually compile.
     */
    static function getBinaryPreprocessor()
    {
        $localBin = __DIR__ . '/bin/';
        $makeFailed = $localBin . 'make-failed';
        if (PHP_OS == 'WINNT') {
            $binary = $localBin . 'preprocessor.exe';
        } else {
            $binary = $localBin . 'preprocessor';
        }

        if (!file_exists($binary) && is_writable($localBin) && !file_exists($makeFailed)) {
            if (PHP_OS == 'WINNT') {
                $success = static::compileBinaryPreprocessorWindows();
            } else {
                $success = static::compileBinaryPreprocessor();
            }
            if (!$success || !file_exists($binary)) {
                touch($makeFailed);
            }
        }

        return $binary;
    }

    static function compileBinaryPreprocessor()
    {
        $make = '/usr/bin/make';
        if (is_executable($make)) {
            $cwd = getcwd();
            chdir(__DIR__);
            exec($make, $output, $retval);
            chdir($cwd);
            return $retval == 0;
        }
        return false;
    }

    static function compileBinaryPreprocessorWindows()
    {
        if (getenv('VSAPPIDDIR')) {
            $cwd = getcwd();
            chdir(__DIR__);
            exec('call "%VSAPPIDDIR%\..\Tools\vsdevcmd\ext\vcvars.bat" && nmake -f nmakefile', $output, $retval);
            chdir($cwd);
            return $retval == 0;
        } elseif (getenv('VS140COMNTOOLS')) {
            $cwd = getcwd();
            chdir(__DIR__);
            exec('call "%VS140COMNTOOLS%\vsvars32.bat" && nmake -f nmakefile', $output, $retval);
            chdir($cwd);
            return $retval == 0;
        }
        return false;
    }
}

require __DIR__ . '/FileHandler.php';

set_time_limit(0);

// Make sure we have a timezone for date functions.
if (ini_get('date.timezone') == '')
    date_default_timezone_set(Webgrind_Config::$defaultTimezone);

function get($param, $default = false)
{
    return (isset($_GET[$param]) ? $_GET[$param] : $default);
}

function sendJson($object)
{
    header('Content-type: application/json');
    echo json_encode($object);
    exit;
}

try {
    switch (get('op')) {
        case 'file_list':
            sendJson(Webgrind_FileHandler::getInstance()->getTraceList());
            break;
        case 'function_list':
            $dataFile = get('dataFile');
            if ($dataFile == '0') {
                $files = Webgrind_FileHandler::getInstance()->getTraceList();
                $dataFile = $files[0]['filename'];
            }
            $reader = Webgrind_FileHandler::getInstance()->getTraceReader($dataFile, get('costFormat', Webgrind_Config::$defaultCostformat));
            $functions = [];
            $shownTotal = 0;
            $breakdown = ['internal' => 0, 'procedural' => 0, 'class' => 0, 'include' => 0];

            for ($i = 0; $i < $reader->getFunctionCount(); $i++) {
                $functionInfo = $reader->getFunctionInfo($i);

                if (false !== strpos($functionInfo['functionName'], 'php::')) {
                    $breakdown['internal'] += $functionInfo['summedSelfCostRaw'];
                    $humanKind = 'internal';
                } else if (false !== strpos($functionInfo['functionName'], 'require_once::') ||
                    false !== strpos($functionInfo['functionName'], 'require::') ||
                    false !== strpos($functionInfo['functionName'], 'include_once::') ||
                    false !== strpos($functionInfo['functionName'], 'include::')) {
                    $breakdown['include'] += $functionInfo['summedSelfCostRaw'];
                    $humanKind = 'include';
                } else {
                    if (false !== strpos($functionInfo['functionName'], '->') || false !== strpos($functionInfo['functionName'], '::')) {
                        $breakdown['class'] += $functionInfo['summedSelfCostRaw'];
                        $humanKind = 'class';
                    } else {
                        $breakdown['procedural'] += $functionInfo['summedSelfCostRaw'];
                        $humanKind = 'procedural';
                    }
                }
                if (!(int)get('hideInternals', 0) || strpos($functionInfo['functionName'], 'php::') === false) {
                    $shownTotal += $functionInfo['summedSelfCostRaw'];
                    $functions[$i] = $functionInfo;
                    $functions[$i]['nr'] = $i;
                    $functions[$i]['humanKind'] = $humanKind;
                }
            }
            usort($functions, function ($a, $b) {
                $a = $a['summedSelfCostRaw'];
                $b = $b['summedSelfCostRaw'];

                if ($a == $b) {
                    return 0;
                }
                return ($a > $b) ? -1 : 1;
            });

            $remainingCost = $shownTotal * get('showFraction');

            $result['functions'] = array();
            foreach ($functions as $function) {
                $remainingCost -= $function['summedSelfCostRaw'];
                $function['file'] = urlencode($function['file']);
                $result['functions'][] = $function;
                if ($remainingCost < 0)
                    break;
            }
            $result['summedInvocationCount'] = $reader->getFunctionCount();
            $result['summedRunTime'] = $reader->formatCost($reader->getHeader('summary'), 'msec');
            $result['dataFile'] = $dataFile;
            $result['invokeUrl'] = $reader->getHeader('cmd');
            $result['runs'] = $reader->getHeader('runs');
            $result['breakdown'] = $breakdown;
            $result['mtime'] = date(Webgrind_Config::$dateFormat, filemtime(Webgrind_Config::xdebugOutputDir() . $dataFile));

            $creator = preg_replace('/[^0-9\.]/', '', $reader->getHeader('creator'));
            $result['linkToFunctionLine'] = version_compare($creator, '2.1') > 0;

            sendJson($result);
            break;
        case 'callinfo_list':
            $reader = Webgrind_FileHandler::getInstance()->getTraceReader(get('file'), get('costFormat', Webgrind_Config::$defaultCostformat));
            $functionNr = get('functionNr');
            $function = $reader->getFunctionInfo($functionNr);

            $result = array('calledFrom' => array(), 'subCalls' => array());
            $foundInvocations = 0;

            for ($i = 0; $i < $function['calledFromInfoCount']; $i++) {
                $invo = $reader->getCalledFromInfo($functionNr, $i);
                $foundInvocations += $invo['callCount'];
                $callerInfo = $reader->getFunctionInfo($invo['functionNr']);
                $invo['file'] = urlencode($callerInfo['file']);
                $invo['callerFunctionName'] = $callerInfo['functionName'];
                $result['calledFrom'][] = $invo;
            }
            $result['calledByHost'] = ($foundInvocations < $function['invocationCount']);

            for ($i = 0; $i < $function['subCallInfoCount']; $i++) {
                $invo = $reader->getSubCallInfo($functionNr, $i);
                $callInfo = $reader->getFunctionInfo($invo['functionNr']);
                $invo['file'] = urlencode($function['file']); // Sub call to $callInfo['file'] but from $function['file']
                $invo['callerFunctionName'] = $callInfo['functionName'];
                $result['subCalls'][] = $invo;
            }
            sendJson($result);
            break;
        case 'clear_files':
            $files = Webgrind_FileHandler::getInstance()->getTraceList();
            if (!$files) {
                sendJson(['done' => 'no files found']);
                break;
            }
            $format = array();
            foreach ($files as $file) {
                unlink(Webgrind_Config::xdebugOutputDir() . $file['filename']);
                $format[] = preg_quote($file['filename'], '/');
            }
            $files = preg_grep('/' . implode('|', $format) . '/', scandir(Webgrind_Config::storageDir()));
            foreach ($files as $file) {
                unlink(Webgrind_Config::storageDir() . $file);
            }
            sendJson(['done' => true]);
            break;
        default:
            $welcome = '';
            if (!file_exists(Webgrind_Config::storageDir()) || !is_writable(Webgrind_Config::storageDir())) {
                $welcome .= 'Webgrind $storageDir does not exist or is not writable: <code>' . Webgrind_Config::storageDir() . '</code><br>';
            }
            if (!file_exists(Webgrind_Config::xdebugOutputDir()) || !is_readable(Webgrind_Config::xdebugOutputDir())) {
                $welcome .= 'Webgrind $profilerDir does not exist or is not readable: <code>' . Webgrind_Config::xdebugOutputDir() . '</code><br>';
            }

            if (empty($welcome)) {
                $welcome = 'Select a cachegrind file above<br>(looking in <code>' . Webgrind_Config::xdebugOutputDir() . '</code> for files matching <code>' . Webgrind_Config::xdebugOutputFormat() . '</code>)';
            }
    }
} catch (Exception $e) {
    sendJson(['error' => $e->getMessage() . '<br>' . $e->getFile() . ', line ' . $e->getLine()]);
    return;
}
?>
<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>webgrind</title>
    <style>
        body {
            font-family: monospace;
            font-size: 12px;
            color: #000000;
            margin: 0;
        }

        a {
            color: #000000;
            text-decoration: none;
        }

        a:hover, #footer a {
            text-decoration: underline;
        }

        img {
            border: 0;
        }

        h2 {
            font-size: 16px;
            margin: 0 0 5px 0;
            font-weight: normal;
        }

        #head {
            padding: 5px 10px 10px 10px;
            border-bottom: 1px solid #404040;
        }

        #logo {
            float: left;
        }

        #logo h1 {
            font-size: 30px;
            padding: 0;
            margin: 0;
        }

        #logo p {
            font-size: 11px;
            margin: 0;
            padding: 0;
        }

        #options {
            float: right;
            padding: 10px 0 0 0;
        }

        #options form {
            margin: 0;
        }

        #main {
            margin: 10px;
        }

        #trace_view {
            display: none;
        }

        #runtime_sum,
        #invocation_sum,
        #shown_sum {
            font-weight: bold;
        }

        div.callinfo_area {
            display: none;
            margin: 5px 5px;
        }

        table.tablesorter {
            border-width: 1px 0 1px 1px;
            border-style: solid;
            border-color: #D9D9D9;
            margin: 10px 0 15px;
            padding: 0;
            font-size: 8pt;
            width: 100%;
            text-align: left;
        }

        table.tablesorter thead tr th, table.tablesorter tfoot tr th {
            background-color: #D7DDE4;
            border-right: 1px solid #CDCDCD;
            border-bottom: 1px solid #CDCDCD;
            font-size: 8pt;
            padding: 4px;
        }

        table.tablesorter thead tr .header {
            background-image: url(img/bg.gif);
            background-repeat: no-repeat;
            background-position: center right;
            cursor: pointer;
        }

        table.tablesorter tbody td {
            color: #000000;
            border-right: 1px solid #D9D9D9;
            padding: 4px;
            vertical-align: top;
        }

        table.tablesorter tbody tr.odd {
            background-color: #EAEEF2;
        }

        table.tablesorter tbody tr.even {
            background-color: #FFFFFF;
        }

        table.tablesorter thead tr .headerSortUp {
            background-image: url(img/asc.gif);
        }

        table.tablesorter thead tr .headerSortDown {
            background-image: url(img/desc.gif);
        }

        table.tablesorter thead tr .headerSortDown, table.tablesorter thead tr .headerSortUp {
            background-color: #9BA8C6;
        }

        td.nr {
            text-align: right;
        }

        th span {
            margin-right: 13px;
        }

        img.list_reload {
            margin: 0 5px;
        }
    </style>
    <link rel="shortcut icon" type="image/ico"
          href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEREREREREAEREREREREQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwAA//8AAAAAAAAAAAAA//8AAAAPAAAADwAA//8AAAADAAAAAwAA//8AAAADAAAAAwAA//8AAAH/AAAB/wAA">
</head>
<body>
<div id="head">
    <div id="logo">
        <h1>webgrind<sup style="font-size:10px">v<?php echo Webgrind_Config::$webgrindVersion ?></sup></h1>
        <p>profiling in the browser</p>
    </div>
    <div id="options">
        <form method="get" onsubmit="window.location.hash='';update();return false;">
            <div style="float:right;margin-left:10px">
                <label for="showFraction" style="margin:0 5px">Show</label>
                <select id="showFraction" name="showFraction">
                    <?php foreach (array(100, 99.7, 98, 95, 90, 82, 68, 50, 26) as $i): ?>
                        <option value="<?php echo $i / 100 ?>"
                                <?php if ($i == Webgrind_Config::$defaultFunctionPercentage): ?>selected="selected"<?php endif; ?>><?php echo $i ?>%
                        </option>
                    <?php endforeach; ?>
                </select>
                <label for="dataFile" style="margin:0 5px">of</label>
                <select id="dataFile" name="dataFile" style="width:200px">
                    <option value="0">Auto (newest)</option>
                    <?php foreach (Webgrind_FileHandler::getInstance()->getTraceList() as $trace): ?>
                        <option value="<?php echo $trace['filename'] ?>"><?php echo str_replace(array('%i', '%f', '%s', '%m'), array($trace['invokeUrl'], $trace['filename'], $trace['filesize'], $trace['mtime']), Webgrind_Config::$traceFileListFormat); ?></option>
                    <?php endforeach; ?>
                </select>
                <img alt="Reload the file list" class="list_reload" src="img/reload.png" onclick="reloadFilelist()">
                <label for="costFormat" style="margin:0 5px">in</label>
                <select id="costFormat" name="costFormat">
                    <option value="percent" <?php echo (Webgrind_Config::$defaultCostformat == 'percent') ? 'selected' : '' ?>>
                        percent
                    </option>
                    <option value="msec" <?php echo (Webgrind_Config::$defaultCostformat == 'msec') ? 'selected' : '' ?>>
                        milliseconds
                    </option>
                    <option value="usec" <?php echo (Webgrind_Config::$defaultCostformat == 'usec') ? 'selected' : '' ?>>
                        microseconds
                    </option>
                </select>
                <input type="submit" value="Update">
                <input type="button" value="&#10006;" onclick="clearFiles()">
            </div>
        </form>
    </div>
    <div style="clear:both;"></div>
</div>
<div id="main">
    <div id="trace_view">
        <div style="float:left;">
            <h2 id="invoke_url"></h2>
            <span id="data_file"></span> @ <span id="mtime"></span>
            <br/>
            <p>
                <label for="callfilter">Filter:</label>
                <input type="text" style="width:150px" id="callfilter"> (regex too)
                <input type="checkbox" name="negateFilter" value="0" id="negateFilter">
                <label for="negateFilter">Invert filter</label>
                <input type="checkbox" name="hideInternals"
                       value="1" <?php echo (Webgrind_Config::$defaultHideInternalFunctions == 1) ? 'checked' : '' ?>
                       id="hideInternals">
                <label for="hideInternals">Hide PHP functions</label>
            </p>
        </div>
        <div style="float:right;">
            <div id="breakdown" style="margin-bottom:5px;width:320px;height:20px"></div>
            <span id="invocation_sum"></span> different functions called in <span id="runtime_sum"></span> milliseconds
            (<span id="runs"></span> runs, <span id="shown_sum"></span> shown)
        </div>
        <table class="tablesorter" id="function_table" cellspacing="0">
            <thead>
            <tr>
                <th></th>
                <th><span>Function</span></th>
                <th></th>
                <?php foreach (Webgrind_Config::$tableFields as $field): ?>
                    <th><span><?php echo $field ?></span></th>
                <?php endforeach; ?>
            </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.31.1/js/jquery.tablesorter.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.1.2/sprintf.min.js" type="text/javascript"></script>
<script>
    let fileUrlFormat = '<?php echo Webgrind_Config::$fileUrlFormat?>';
    let currentDataFile = null;
    let callInfoLoaded = [];

    function update(specificFile) {
        $.getJSON("index.php",
            {
                dataFile: specificFile || $("#dataFile").val(),
                costFormat: $('#costFormat').val(),
                showFraction: $("#showFraction").val(),
                hideInternals: $('#hideInternals').attr('checked') ? 1 : 0,
                op: 'function_list'
            },
            function (data) {
                if (data.error) {
                    alert(data.error);
                    return;
                }
                callInfoLoaded = [];
                $("#function_table tbody").empty();

                data.functions.forEach(function (rowData) {
                    callInfoLoaded[rowData.nr] = false;
                    let openLink;

                    if (rowData.file === 'php%3Ainternal') {
                        openLink = '<a title="Lookup function" href="https://secure.php.net/' + rowData.functionName.substr(5).replace("->", ".") + '" target="_blank"><img src="img/file.png" alt="O"></a>';
                    } else {
                        if (data.linkToFunctionLine) {
                            openLink = '<a title="Open file and show line" href="' + sprintf(fileUrlFormat, rowData.file, rowData.line) + '" target="_blank"><img src="img/file_line.png" alt="O"></a>';
                        } else {
                            openLink = '<a title="Open file" href="' + sprintf(fileUrlFormat, rowData.file, -1) + '" target="_blank"><img src="img/file.png" alt="O"></a>';
                        }
                    }
                    let functionTableRow = '<tr> \
						<td><img src="img/call_' + rowData.humanKind + '.png" title="' + rowData.humanKind + '"></td> \
						<td> \
							<a id="callinfo_a_' + rowData.nr + '" href="javascript:toggleCallInfo(' + rowData.nr + ')"> \
								<img id="fold_marker_' + rowData.nr + '" src="img/right.gif">&nbsp;&nbsp;' + rowData.functionName + ' \
							</a> \
							<div class="callinfo_area" id="callinfo_area_' + rowData.nr + '"></div> \
						</td> \
						<td>' + openLink + '</td> \
						<?php
                        $dataCodes = array(
                            'Invocation Count' => 'rowData.invocationCount',
                            'Total Self Cost' => 'rowData.summedSelfCost',
                            'Average Self Cost' => 'sprintf("%.2f", rowData.summedSelfCost/rowData.invocationCount)',
                            'Total Inclusive Cost' => 'rowData.summedInclusiveCost',
                            'Average Inclusive Cost' => 'sprintf("%.2f", rowData.summedInclusiveCost/data.invocationCount)',
                        );
                        foreach (Webgrind_Config::$tableFields as $field) {
                            echo "<td class=\"nr\">'+$dataCodes[$field]+'</td> \\\n\t\t\t\t\t\t";
                        }
                        ?>
                        < /tr>';
                    $("#function_table tbody").append(functionTableRow);
                });

                currentDataFile = data.dataFile;
                $("#data_file").html(data.dataFile);
                $("#invoke_url").html(data.invokeUrl);
                $(document).attr('title', 'webgrind of ' + data.invokeUrl);
                $("#mtime").html(data.mtime);
                $("#shown_sum").html(data.functions.length);
                $("#invocation_sum").html(data.summedInvocationCount);
                $("#runtime_sum").html(data.summedRunTime);
                $("#runs").html(data.runs);

                let breakdown_sum = data.breakdown['internal'] + data.breakdown['procedural'] + data.breakdown['class'] + data.breakdown['include'];
                $("#breakdown").html(
                    '<img src="img/gradient_left.png" height="20" width="10">' +
                    '<img src="img/gradient_internal.png" title="internal functions" height="20" width="' + Math.floor(data.breakdown['internal'] / breakdown_sum * 300) + '">' +
                    '<img src="img/gradient_include.png" title="include/require" height="20" width="' + Math.floor(data.breakdown['include'] / breakdown_sum * 300) + '">' +
                    '<img src="img/gradient_class.png" title="class methods" height="20" width="' + Math.floor(data.breakdown['class'] / breakdown_sum * 300) + '">' +
                    '<img src="img/gradient_procedural.png" title="procedural functions" height="20" width="' + Math.floor(data.breakdown['procedural'] / breakdown_sum * 300) + '">' +
                    '<img src="img/gradient_right.png" height="20" width="10">'
                );

                $("#trace_view").show();

                let functionTable = $("#function_table");
                functionTable.trigger('update');
                <?php
                $sortCol = 0;
                foreach (Webgrind_Config::$tableFields as $idx => $field) {
                    if (strpos($field, 'Cost') !== FALSE) {
                        $sortCol = 3 + $idx;
                        break;
                    }
                }
                $maxCol = 3 + count(Webgrind_Config::$tableFields);
                ?>
                functionTable.trigger("sorton", [[[<?php echo $sortCol?>, 1]]]);

                $('#callfilter').trigger('keyup');
                if (window.location.hash.length > 2)
                    openCallInfo(window.location.hash.replace(/[^0-9]/g, ''));
            }
        );
    }

    function insertCallInfo(functionNr, idPrefix, title, data) {
        if (data.length === 0)
            return;

        let callTable = '<table class="tablesorter" id="' + idPrefix + functionNr + '" cellspacing="0"><thead><tr><th><span>' + title + '</span></th><th><span>Count</span></th><th><span>Total Call Cost</span></th><th></th></tr></thead><tbody></tbody></table>';
        $("#callinfo_area_" + functionNr).append(callTable);

        data.forEach(function (data) {
            let callTableRow = '<tr><td>'
                + ($("#callinfo_area_" + data.functionNr).length ? '<img src="img/right.gif">&nbsp;&nbsp;<a href="javascript:openCallInfo(' + data.functionNr + ')">' + data.callerFunctionName + '</a>' : '<img src="img/blank.gif">&nbsp;&nbsp;' + data.callerFunctionName)
                + ' @ ' + data.line + '</td> \
						<td class="nr">' + data.callCount + '</td> \
						<td class="nr">' + data.summedCallCost + '</td> \
						<td><a title="Open file and show line" href="' + sprintf(fileUrlFormat, data.file, data.line) + '" target="_blank"><img src="img/file_line.png" alt="O"></a></td> \
					</tr>';
            $("#" + idPrefix + functionNr + " tbody").append(callTableRow);
        });

        let functionDiv = $("#" + idPrefix + functionNr);

        functionDiv.tablesorter({
            widgets: ['zebra'],
            headers: {
                3: {
                    sorter: false
                }
            }
        });
        functionDiv.trigger("sorton", [[[2, 1]]]);
    }

    function toggleCallInfo(functionNr) {
        let $ciar = $("#callinfo_area_" + functionNr);
        let fmimg = $("#fold_marker_" + functionNr).get(0);
        if ($ciar.is(":visible")) {
            $ciar.hide();
            fmimg.src = 'img/right.gif';
        } else {
            if (!callInfoLoaded[functionNr]) {
                $.getJSON("index.php",
                    {
                        'op': 'callinfo_list',
                        'file': currentDataFile,
                        'functionNr': functionNr,
                        'costFormat': $("#costFormat").val()
                    },
                    function (data) {
                        if (data.error) {
                            alert(data.error);
                            return;
                        }

                        if (data.calledByHost)
                            $("#callinfo_area_" + functionNr).append('<b>Called from script host</b>');

                        insertCallInfo(functionNr, 'sub_calls_table_', 'Calls', data.subCalls);
                        insertCallInfo(functionNr, 'called_from_table_', 'Called From', data.calledFrom);

                        callInfoLoaded[functionNr] = true;
                        window.location.hash = "#callinfo_a_" + functionNr;
                    }
                );
            } else {
                window.location.hash = "#callinfo_a_" + functionNr;
            }
            $ciar.show();
            fmimg.src = 'img/down.gif';
        }
    }

    function openCallInfo(functionNr) {
        let areaEl = $("#callinfo_area_" + functionNr);
        if (areaEl.length) {
            if (areaEl.is(":hidden")) {
                toggleCallInfo(functionNr);
            } else {
                window.location.hash = "#callinfo_a_" + functionNr;
            }
            window.scrollTo(0, areaEl.parent().offset().top);
            setTimeout(function () {
                areaEl.parent().parent().css({'background-color': '#DFECE0'})
            }, 50);
            setTimeout(function () {
                areaEl.parent().parent().css({'background-color': ''})
            }, 600);
        }
    }

    function reloadFilelist() {
        $.getJSON("index.php",
            {'op': 'file_list'},
            function (data) {
                let datafile = $("#dataFile");
                datafile.find('option').remove();
                datafile.append('<option value="0">Auto (newest)</option>');
                data.forEach(function (d) {
                    datafile.append('<option value="' + d['filename'] + '">' + d['invokeUrl'] + ' (' + d['filename'] + ') [' + d['filesize'] + ']' + '</option>');
                });
            }
        );
    }

    function clearFiles() {
        if (!window.confirm('Are you sure you want to clear all files?'))
            return;

        $.getJSON("index.php",
            {'op': 'clear_files'},
            function (data) {
                if (data.error) {
                    alert(data.error);
                    return;
                }
                reloadFilelist();
            }
        );
    }

    $(document).ready(function () {
        $("#function_table").tablesorter({
            widgets: ['zebra'],
            sortInitialOrder: 'desc',
            headers: {
                1: {
                    sorter: false
                },
                2: {
                    sorter: false
                }
            }
        });

        if (document.location.hash) {
            update();
        }

        $("#hideInternals").change(function () {
            update();
        });

        $("#negateFilter").change(function () {
            $('#callfilter').trigger('keyup');
        });

        $("#callfilter").keyup(function () {
            let reg = new RegExp($(this).val(), 'i');
            let negate = $("#negateFilter").is(':checked');
            let row;
            $('#function_table').children('tbody').children('tr').each(function () {
                row = $(this);
                if (!row.find('td:eq(1) a').text().match(reg) === negate)
                    row.css('display', 'table-row');
                else
                    row.css('display', 'none');
            });
        });

        window.addEventListener("hashchange", function () {
            if (window.location.hash.length > 2)
                openCallInfo(window.location.hash.replace(/[^0-9]/g, ''));
        });
    });
</script>
</body>
</html>
